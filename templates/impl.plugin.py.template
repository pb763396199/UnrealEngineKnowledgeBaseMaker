"""
{PLUGIN_NAME} 插件知识库查询实现

提供模块级查询和代码级查询功能
"""

import os
import pickle
import sqlite3
import json
from pathlib import Path
from typing import Dict, List, Any, Optional

# 知识库路径 (绝对路径)
KB_PATH = Path(r"{KB_PATH}")

# 全局缓存
_global_index_cache = None
_module_graphs_cache = {{}}
_db_connection = None
_class_index_cache = None
_function_index_cache = None


# ============================================================================
# 辅助函数
# ============================================================================

def _get_db_connection() -> sqlite3.Connection:
    """获取 SQLite 数据库连接"""
    global _db_connection
    if _db_connection is None:
        db_path = KB_PATH / "global_index" / "index.db"
        if not db_path.exists():
            raise FileNotFoundError(f"数据库不存在: {{db_path}}")
        _db_connection = sqlite3.connect(str(db_path))
    return _db_connection


def _load_module_graph(module_name: str) -> Optional[Any]:
    """加载模块图谱（带缓存）"""
    if module_name in _module_graphs_cache:
        return _module_graphs_cache[module_name]

    graph_file = KB_PATH / "module_graphs" / f"{{module_name}}.pkl"
    if not graph_file.exists():
        return None

    try:
        with open(graph_file, 'rb') as f:
            data = pickle.load(f)
            graph = data.get('graph')
            _module_graphs_cache[module_name] = graph
            return graph
    except Exception as e:
        return None


def _get_global_modules() -> Dict[str, Any]:
    """获取所有模块信息（从 SQLite）"""
    global _global_index_cache
    if _global_index_cache is not None:
        return _global_index_cache

    conn = _get_db_connection()
    cursor = conn.cursor()

    cursor.execute('''
        SELECT name, path, category, dependencies, public_dependencies, private_dependencies
        FROM modules
    ''')

    result = {{}}
    for row in cursor.fetchall():
        name, path, category, deps, pub_deps, priv_deps = row
        result[name] = {{
            'name': name,
            'path': path,
            'category': category,
            'dependencies': json.loads(deps) if deps else [],
            'public_dependencies': json.loads(pub_deps) if pub_deps else [],
            'private_dependencies': json.loads(priv_deps) if priv_deps else []
        }}

    _global_index_cache = result
    return result


def _get_class_index():
    """获取类索引"""
    global _class_index_cache
    if _class_index_cache is None:
        from ue5_kb.core.class_index import ClassIndex
        db_path = KB_PATH / "global_index" / "class_index.db"
        if db_path.exists():
            _class_index_cache = ClassIndex(str(db_path))
    return _class_index_cache


def _get_function_index():
    """获取函数索引"""
    global _function_index_cache
    if _function_index_cache is None:
        from ue5_kb.core.function_index import FunctionIndex
        db_path = KB_PATH / "global_index" / "function_index.db"
        if db_path.exists():
            _function_index_cache = FunctionIndex(str(db_path))
    return _function_index_cache


# ============================================================================
# 模块级查询功能
# ============================================================================

def query_module_dependencies(module_name: str) -> Dict[str, Any]:
    """查询模块依赖关系"""
    all_modules = _get_global_modules()

    if module_name not in all_modules:
        return {{
            "error": f"未找到模块: {{module_name}}",
            "fallback_command": f"search_modules {{module_name}}",
            "hint": "模块名可能已变更或拼写不同，建议使用模糊搜索",
            "suggestions": list(all_modules.keys())[:10]
        }}

    info = all_modules[module_name]
    return {{
        "module": module_name,
        "path": info['path'],
        "category": info['category'],
        "dependencies": info['dependencies'],
        "public_dependencies": info['public_dependencies'],
        "private_dependencies": info['private_dependencies']
    }}


def search_modules(keyword: str) -> Dict[str, Any]:
    """搜索包含关键字的模块"""
    all_modules = _get_global_modules()
    results = []

    keyword_lower = keyword.lower()
    for name, info in all_modules.items():
        if keyword_lower in name.lower():
            results.append({{
                "name": name,
                "category": info['category'],
                "path": info['path']
            }})

    return {{
        "keyword": keyword,
        "found_count": len(results),
        "results": results[:50]
    }}


def get_statistics() -> Dict[str, Any]:
    """获取知识库统计信息"""
    all_modules = _get_global_modules()

    # 统计分类
    categories = {{}}
    for info in all_modules.values():
        cat = info['category'] or 'Unknown'
        categories[cat] = categories.get(cat, 0) + 1

    return {{
        "total_modules": len(all_modules),
        "categories": categories
    }}


# ============================================================================
# 代码级查询功能
# ============================================================================

def query_class_info(class_name: str) -> Dict[str, Any]:
    """查询类的详细信息"""
    # 查找类所在的模块
    module_name = _find_module_for_class(class_name)
    if not module_name:
        return {{
            "error": f"未找到类: {{class_name}}",
            "fallback_command": f"search_classes {{class_name}}",
            "hint": "类名可能已变更或拼写不同，建议使用模糊搜索"
        }}

    # 加载模块图谱
    graph = _load_module_graph(module_name)
    if not graph:
        return {{"error": f"无法加载模块图谱: {{module_name}}"}}

    # 查找类节点
    class_node = f"class_{{class_name}}"
    if class_node not in graph.nodes:
        return {{"error": f"类 {{class_name}} 不在模块 {{module_name}} 的图谱中"}}

    # 提取类信息
    node_data = graph.nodes[class_node]

    return {{
        "class_name": class_name,
        "module": module_name,
        "file": node_data.get('file', ''),
        "line": node_data.get('line', 0),
        "parent_classes": node_data.get('parent_classes', []),
        "is_uclass": node_data.get('is_uclass', False),
        "is_struct": node_data.get('is_struct', False),
        "is_interface": node_data.get('is_interface', False)
    }}


def query_class_hierarchy(class_name: str, depth: int = 3) -> Dict[str, Any]:
    """查询类的继承层次结构"""
    result = []
    current_class = class_name

    for i in range(depth):
        info = query_class_info(current_class)
        if 'error' in info:
            break

        result.append({{
            "level": i,
            "class": current_class,
            "module": info.get("module"),
            "file": info.get("file")
        }})

        parents = info.get("parent_classes", [])
        if not parents:
            break

        current_class = parents[0]

    return {{
        "class": class_name,
        "hierarchy": result,
        "depth": len(result)
    }}


def query_module_classes(module_name: str, class_type: str = None) -> Dict[str, Any]:
    """查询模块中的所有类"""
    graph = _load_module_graph(module_name)
    if not graph:
        return {{"error": f"无法加载模块图谱: {{module_name}}"}}

    classes = []
    for node, node_data in graph.nodes(data=True):
        if node_data.get('type') != 'class':
            continue

        if class_type == 'uclass' and not node_data.get('is_uclass'):
            continue
        elif class_type == 'struct' and not node_data.get('is_struct'):
            continue
        elif class_type == 'interface' and not node_data.get('is_interface'):
            continue

        class_name = node_data.get('name', node.replace('class_', ''))
        classes.append({{
            "name": class_name,
            "is_uclass": node_data.get('is_uclass', False),
            "is_struct": node_data.get('is_struct', False),
            "file": node_data.get('file', '')
        }})

    return {{
        "module": module_name,
        "total_classes": len(classes),
        "classes": classes[:100]
    }}


def query_function_info(function_name: str, module_hint: str = None) -> Dict[str, Any]:
    """查询函数信息"""
    results = []

    # 确定要搜索的模块
    if module_hint:
        modules = [module_hint]
    else:
        all_modules = _get_global_modules()
        modules = list(all_modules.keys())[:50]

    # 搜索函数
    for mod in modules:
        graph = _load_module_graph(mod)
        if not graph:
            continue

        for node, node_data in graph.nodes(data=True):
            if node_data.get('type') != 'function':
                continue

            if node_data.get('name') == function_name:
                results.append({{
                    "function": function_name,
                    "module": mod,
                    "return_type": node_data.get('return_type', ''),
                    "parameters": node_data.get('parameters', []),
                    "is_ufunction": node_data.get('is_ufunction', False),
                    "is_blueprint_callable": node_data.get('is_blueprint_callable', False),
                    "file": node_data.get('file', ''),
                    "line": node_data.get('line', 0),
                    "impl_file": node_data.get('impl_file', ''),
                    "impl_line": node_data.get('impl_line', 0),
                    "class": node_data.get('class_name', '')
                }})

    if not results:
        # 提取关键字用于模糊搜索
        keyword = function_name[:8] if len(function_name) > 8 else function_name
        return {{
            "error": f"未找到函数: {{function_name}}",
            "fallback_command": f"search_functions {{keyword}}",
            "hint": "函数名可能已变更或拼写不同，建议使用模糊搜索"
        }}

    return {{
        "function_name": function_name,
        "found_count": len(results),
        "results": results[:20]
    }}


def search_classes(keyword: str, limit: int = 50) -> Dict[str, Any]:
    """搜索包含关键字的类"""
    class_idx = _get_class_index()

    if class_idx:
        # 使用索引搜索（快速 < 10ms）
        results = class_idx.search_by_keyword(keyword, limit)
        return {{
            "keyword": keyword,
            "found_count": len(results),
            "results": results
        }}
    else:
        # 回退到遍历搜索（慢速 ~5s）
        all_modules = _get_global_modules()
        results = []
        keyword_lower = keyword.lower()

        for module_name in list(all_modules.keys())[:100]:
            graph = _load_module_graph(module_name)
            if not graph:
                continue

            for node, node_data in graph.nodes(data=True):
                if node_data.get('type') != 'class':
                    continue

                class_name = node_data.get('name', '')
                if keyword_lower in class_name.lower():
                    results.append({{
                        "class": class_name,
                        "module": module_name,
                        "is_uclass": node_data.get('is_uclass', False),
                        "file": node_data.get('file', '')
                    }})

                    if len(results) >= limit:
                        break

            if len(results) >= limit:
                break

        return {{
            "keyword": keyword,
            "found_count": len(results),
            "results": results
        }}


def search_functions(keyword: str, limit: int = 50) -> Dict[str, Any]:
    """搜索包含关键字的函数"""
    func_idx = _get_function_index()

    if func_idx:
        # 使用索引搜索（快速 < 10ms）
        results = func_idx.search_by_keyword(keyword, limit)
        return {{
            "keyword": keyword,
            "found_count": len(results),
            "results": results
        }}
    else:
        # 回退到遍历搜索（慢速 ~8s）
        all_modules = _get_global_modules()
        results = []
        keyword_lower = keyword.lower()

        for module_name in list(all_modules.keys())[:100]:
            graph = _load_module_graph(module_name)
            if not graph:
                continue

            for node, node_data in graph.nodes(data=True):
                if node_data.get('type') != 'function':
                    continue

                function_name = node_data.get('name', '')
                if keyword_lower in function_name.lower():
                    results.append({{
                        "function": function_name,
                        "module": module_name,
                        "return_type": node_data.get('return_type', ''),
                        "file": node_data.get('file', ''),
                        "impl_file": node_data.get('impl_file', ''),
                        "class": node_data.get('class_name', '')
                    }})

                    if len(results) >= limit:
                        break

            if len(results) >= limit:
                break

        return {{
            "keyword": keyword,
            "found_count": len(results),
            "results": results
        }}


# ============================================================================
# 内部辅助函数
# ============================================================================

def _find_module_for_class(class_name: str) -> Optional[str]:
    """查找类所在的模块"""
    all_modules = _get_global_modules()

    # 优先级列表
    priority_modules = ['Core', 'CoreUObject', 'Engine', 'Renderer', 'RHI']

    # 1. 先搜索优先级模块
    for module_name in priority_modules:
        graph = _load_module_graph(module_name)
        if graph and f"class_{{class_name}}" in graph.nodes:
            return module_name

    # 2. 搜索所有 Runtime 模块
    for module_name, info in all_modules.items():
        if info.get('category') == 'Runtime':
            if module_name in priority_modules:
                continue
            graph = _load_module_graph(module_name)
            if graph and f"class_{{class_name}}" in graph.nodes:
                return module_name

    # 3. 搜索所有模块（限制前200个）
    for module_name in list(all_modules.keys())[:200]:
        if module_name in priority_modules:
            continue
        graph = _load_module_graph(module_name)
        if graph and f"class_{{class_name}}" in graph.nodes:
            return module_name

    return None


def get_function_implementation(function_name: str, class_name: str = None, module_hint: str = None) -> Dict[str, Any]:
    """
    获取函数的实现代码

    首先查询函数索引找到实现文件位置，然后读取 cpp 文件内容返回。
    这是解决 LLM 需要查看函数实现的核心功能。

    Args:
        function_name: 函数名称
        class_name: 类名称（可选，用于处理同名函数）
        module_hint: 模块提示（可选，用于加速查询）

    Returns:
        包含函数实现信息的字典
    """
    func_idx = _get_function_index()
    if not func_idx:
        return {"error": "Function index not available"}

    # 查询函数信息
    results = func_idx.query_by_name(function_name, module_hint)
    if class_name:
        results = [r for r in results if r.get('class_name') == class_name]

    if not results:
        return {"error": f"Function {function_name} not found"}

    # 获取第一个匹配结果的实现文件
    func_info = results[0]
    impl_file = func_info.get('impl_file_path')
    impl_line = func_info.get('impl_line_number', 0)

    if not impl_file or not os.path.exists(impl_file):
        return {
            "error": f"Implementation file not found for {function_name}",
            "declaration_location": f"{func_info.get('file_path')}:{func_info.get('line_number')}"
        }

    # 读取实现文件内容
    try:
        with open(impl_file, 'r', encoding='utf-8', errors='ignore') as f:
            content = f.read()

        return {
            "function": function_name,
            "class": func_info.get('class_name'),
            "module": func_info.get('module'),
            "declaration_file": func_info.get('file_path'),
            "declaration_line": func_info.get('line_number'),
            "implementation_file": impl_file,
            "implementation_line": impl_line,
            "file_content": content if len(content) < 10000 else content[:10000] + "... (truncated)"
        }
    except Exception as e:
        return {"error": f"Failed to read implementation file: {e}"}


# ============================================================================
# 命令行接口 (CLI)
# ============================================================================

if __name__ == "__main__":
    import sys
    import json

    def _print_usage():
        print("Usage: python impl.py <command> [args...]", file=sys.stderr)
        print("", file=sys.stderr)
        print("Commands:", file=sys.stderr)
        print("  query_class_info <class_name>              - 查询类信息", file=sys.stderr)
        print("  query_class_hierarchy <class_name> [depth] - 查询类继承关系", file=sys.stderr)
        print("  query_module_dependencies <module_name>    - 查询模块依赖", file=sys.stderr)
        print("  query_module_classes <module_name> [type]  - 查询模块中的类", file=sys.stderr)
        print("  query_function_info <function_name> [hint] - 查询函数信息", file=sys.stderr)
        print("  get_function_implementation <function_name> [class_name] [hint] - 获取函数实现", file=sys.stderr)
        print("  search_functions <keyword> [limit]         - 搜索函数", file=sys.stderr)
        print("  search_classes <keyword> [limit]           - 搜索类", file=sys.stderr)
        print("  search_modules <keyword>                   - 搜索模块", file=sys.stderr)
        print("  get_statistics                             - 获取统计信息", file=sys.stderr)
        print("", file=sys.stderr)
        print("Examples:", file=sys.stderr)
        print('  python impl.py query_class_info AActor', file=sys.stderr)
        print('  python impl.py query_class_hierarchy AActor 5', file=sys.stderr)
        print('  python impl.py search_classes "Player" 20', file=sys.stderr)
        sys.exit(1)

    if len(sys.argv) < 2:
        _print_usage()

    command = sys.argv[1]

    try:
        if command == "query_class_info":
            if len(sys.argv) < 3:
                print("Error: Missing class_name argument", file=sys.stderr)
                _print_usage()
            result = query_class_info(sys.argv[2])
            print(json.dumps(result, ensure_ascii=False, indent=2))

        elif command == "query_class_hierarchy":
            if len(sys.argv) < 3:
                print("Error: Missing class_name argument", file=sys.stderr)
                _print_usage()
            depth = int(sys.argv[3]) if len(sys.argv) > 3 else 3
            result = query_class_hierarchy(sys.argv[2], depth)
            print(json.dumps(result, ensure_ascii=False, indent=2))

        elif command == "query_module_dependencies":
            if len(sys.argv) < 3:
                print("Error: Missing module_name argument", file=sys.stderr)
                _print_usage()
            result = query_module_dependencies(sys.argv[2])
            print(json.dumps(result, ensure_ascii=False, indent=2))

        elif command == "query_module_classes":
            if len(sys.argv) < 3:
                print("Error: Missing module_name argument", file=sys.stderr)
                _print_usage()
            class_type = sys.argv[3] if len(sys.argv) > 3 else None
            result = query_module_classes(sys.argv[2], class_type)
            print(json.dumps(result, ensure_ascii=False, indent=2))

        elif command == "query_function_info":
            if len(sys.argv) < 3:
                print("Error: Missing function_name argument", file=sys.stderr)
                _print_usage()
            module_hint = sys.argv[3] if len(sys.argv) > 3 else None
            result = query_function_info(sys.argv[2], module_hint)
            print(json.dumps(result, ensure_ascii=False, indent=2))

        elif command == "get_function_implementation":
            if len(sys.argv) < 3:
                print("Error: Missing function_name argument", file=sys.stderr)
                _print_usage()
            class_name = sys.argv[3] if len(sys.argv) > 3 else None
            module_hint = sys.argv[4] if len(sys.argv) > 4 else None
            result = get_function_implementation(sys.argv[2], class_name, module_hint)
            print(json.dumps(result, ensure_ascii=False, indent=2))

        elif command == "search_functions":
            if len(sys.argv) < 3:
                print("Error: Missing keyword argument", file=sys.stderr)
                _print_usage()
            limit = int(sys.argv[3]) if len(sys.argv) > 3 else 50
            result = search_functions(sys.argv[2], limit)
            print(json.dumps(result, ensure_ascii=False, indent=2))

        elif command == "search_classes":
            if len(sys.argv) < 3:
                print("Error: Missing keyword argument", file=sys.stderr)
                _print_usage()
            limit = int(sys.argv[3]) if len(sys.argv) > 3 else 50
            result = search_classes(sys.argv[2], limit)
            print(json.dumps(result, ensure_ascii=False, indent=2))

        elif command == "search_modules":
            if len(sys.argv) < 3:
                print("Error: Missing keyword argument", file=sys.stderr)
                _print_usage()
            result = search_modules(sys.argv[2])
            print(json.dumps(result, ensure_ascii=False, indent=2))

        elif command == "get_statistics":
            result = get_statistics()
            print(json.dumps(result, ensure_ascii=False, indent=2))

        else:
            print(f"Error: Unknown command '{command}'", file=sys.stderr)
            _print_usage()

    except Exception as e:
        error_result = {"error": str(e), "command": command, "args": sys.argv[2:]}
        print(json.dumps(error_result, ensure_ascii=False, indent=2))
        sys.exit(1)
