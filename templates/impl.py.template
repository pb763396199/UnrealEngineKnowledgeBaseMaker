"""
UE{ENGINE_VERSION} 知识库查询实现

提供模块级查询和代码级查询功能
"""

import os
import pickle
import sqlite3
import json
from pathlib import Path
from typing import Dict, List, Any, Optional

# 知识库路径 (绝对路径)
KB_PATH = Path(r"{KB_PATH}")

# 全局缓存
_global_index_cache = None
_module_graphs_cache = {{}}
_db_connection = None


# ============================================================================
# 辅助函数
# ============================================================================

def _get_db_connection() -> sqlite3.Connection:
    """获取 SQLite 数据库连接"""
    global _db_connection
    if _db_connection is None:
        db_path = KB_PATH / "global_index" / "index.db"
        if not db_path.exists():
            raise FileNotFoundError(f"数据库不存在: {{db_path}}")
        _db_connection = sqlite3.connect(str(db_path))
    return _db_connection


def _load_module_graph(module_name: str) -> Optional[Any]:
    """加载模块图谱（带缓存）"""
    if module_name in _module_graphs_cache:
        return _module_graphs_cache[module_name]

    graph_file = KB_PATH / "module_graphs" / f"{{module_name}}.pkl"
    if not graph_file.exists():
        return None

    try:
        with open(graph_file, 'rb') as f:
            data = pickle.load(f)
            graph = data.get('graph')
            _module_graphs_cache[module_name] = graph
            return graph
    except Exception as e:
        return None


def _get_global_modules() -> Dict[str, Any]:
    """获取所有模块信息（从 SQLite）"""
    global _global_index_cache
    if _global_index_cache is not None:
        return _global_index_cache

    conn = _get_db_connection()
    cursor = conn.cursor()

    cursor.execute('''
        SELECT name, path, category, dependencies, public_dependencies, private_dependencies
        FROM modules
    ''')

    result = {{}}
    for row in cursor.fetchall():
        name, path, category, deps, pub_deps, priv_deps = row
        result[name] = {{
            'name': name,
            'path': path,
            'category': category,
            'dependencies': json.loads(deps) if deps else [],
            'public_dependencies': json.loads(pub_deps) if pub_deps else [],
            'private_dependencies': json.loads(priv_deps) if priv_deps else []
        }}

    _global_index_cache = result
    return result


# ============================================================================
# 模块级查询功能
# ============================================================================

def query_module_dependencies(module_name: str) -> Dict[str, Any]:
    """查询模块依赖关系"""
    all_modules = _get_global_modules()

    if module_name not in all_modules:
        return {{"error": f"未找到模块: {{module_name}}", "suggestions": list(all_modules.keys())[:10]}}

    info = all_modules[module_name]
    return {{
        "module": module_name,
        "path": info['path'],
        "category": info['category'],
        "dependencies": info['dependencies'],
        "public_dependencies": info['public_dependencies'],
        "private_dependencies": info['private_dependencies']
    }}


def search_modules(keyword: str) -> Dict[str, Any]:
    """搜索包含关键字的模块"""
    all_modules = _get_global_modules()
    results = []

    keyword_lower = keyword.lower()
    for name, info in all_modules.items():
        if keyword_lower in name.lower():
            results.append({{
                "name": name,
                "category": info['category'],
                "path": info['path']
            }})

    return {{
        "keyword": keyword,
        "found_count": len(results),
        "results": results[:50]
    }}


def get_statistics() -> Dict[str, Any]:
    """获取知识库统计信息"""
    all_modules = _get_global_modules()

    # 统计分类
    categories = {{}}
    for info in all_modules.values():
        cat = info['category'] or 'Unknown'
        categories[cat] = categories.get(cat, 0) + 1

    return {{
        "total_modules": len(all_modules),
        "categories": categories
    }}


# ============================================================================
# 代码级查询功能
# ============================================================================

def query_class_info(class_name: str) -> Dict[str, Any]:
    """查询类的详细信息"""
    # 查找类所在的模块
    module_name = _find_module_for_class(class_name)
    if not module_name:
        return {{"error": f"未找到类: {{class_name}}"}}

    # 加载模块图谱
    graph = _load_module_graph(module_name)
    if not graph:
        return {{"error": f"无法加载模块图谱: {{module_name}}"}}

    # 查找类节点
    class_node = f"class_{{class_name}}"
    if class_node not in graph.nodes:
        return {{"error": f"类 {{class_name}} 不在模块 {{module_name}} 的图谱中"}}

    # 提取类信息
    node_data = graph.nodes[class_node]

    return {{
        "class_name": class_name,
        "module": module_name,
        "file": node_data.get('file', ''),
        "line": node_data.get('line', 0),
        "parent_classes": node_data.get('parent_classes', []),
        "is_uclass": node_data.get('is_uclass', False),
        "is_struct": node_data.get('is_struct', False),
        "is_interface": node_data.get('is_interface', False)
    }}


def query_class_hierarchy(class_name: str, depth: int = 3) -> Dict[str, Any]:
    """查询类的继承层次结构"""
    result = []
    current_class = class_name

    for i in range(depth):
        info = query_class_info(current_class)
        if 'error' in info:
            break

        result.append({{
            "level": i,
            "class": current_class,
            "module": info.get("module"),
            "file": info.get("file")
        }})

        parents = info.get("parent_classes", [])
        if not parents:
            break

        current_class = parents[0]

    return {{
        "class": class_name,
        "hierarchy": result,
        "depth": len(result)
    }}


def query_module_classes(module_name: str, class_type: str = None) -> Dict[str, Any]:
    """查询模块中的所有类"""
    graph = _load_module_graph(module_name)
    if not graph:
        return {{"error": f"无法加载模块图谱: {{module_name}}"}}

    classes = []
    for node, node_data in graph.nodes(data=True):
        if node_data.get('type') != 'class':
            continue

        if class_type == 'uclass' and not node_data.get('is_uclass'):
            continue
        elif class_type == 'struct' and not node_data.get('is_struct'):
            continue
        elif class_type == 'interface' and not node_data.get('is_interface'):
            continue

        class_name = node_data.get('name', node.replace('class_', ''))
        classes.append({{
            "name": class_name,
            "is_uclass": node_data.get('is_uclass', False),
            "is_struct": node_data.get('is_struct', False),
            "file": node_data.get('file', '')
        }})

    return {{
        "module": module_name,
        "total_classes": len(classes),
        "classes": classes[:100]
    }}


def query_function_info(function_name: str, module_hint: str = None) -> Dict[str, Any]:
    """查询函数信息"""
    results = []

    # 确定要搜索的模块
    if module_hint:
        modules = [module_hint]
    else:
        all_modules = _get_global_modules()
        modules = list(all_modules.keys())[:50]

    # 搜索函数
    for mod in modules:
        graph = _load_module_graph(mod)
        if not graph:
            continue

        for node, node_data in graph.nodes(data=True):
            if node_data.get('type') != 'function':
                continue

            if node_data.get('name') == function_name:
                results.append({{
                    "function": function_name,
                    "module": mod,
                    "return_type": node_data.get('return_type', ''),
                    "parameters": node_data.get('parameters', []),
                    "is_ufunction": node_data.get('is_ufunction', False),
                    "is_blueprint_callable": node_data.get('is_blueprint_callable', False),
                    "file": node_data.get('file', ''),
                    "line": node_data.get('line', 0),
                    "class": node_data.get('class_name', '')
                }})

    return {{
        "function_name": function_name,
        "found_count": len(results),
        "results": results[:20]
    }}


def search_classes(keyword: str, limit: int = 50) -> Dict[str, Any]:
    """搜索包含关键字的类"""
    all_modules = _get_global_modules()
    results = []
    keyword_lower = keyword.lower()

    for module_name in list(all_modules.keys())[:100]:
        graph = _load_module_graph(module_name)
        if not graph:
            continue

        for node, node_data in graph.nodes(data=True):
            if node_data.get('type') != 'class':
                continue

            class_name = node_data.get('name', '')
            if keyword_lower in class_name.lower():
                results.append({{
                    "class": class_name,
                    "module": module_name,
                    "is_uclass": node_data.get('is_uclass', False),
                    "file": node_data.get('file', '')
                }})

                if len(results) >= limit:
                    break

        if len(results) >= limit:
            break

    return {{
        "keyword": keyword,
        "found_count": len(results),
        "results": results
    }}


# ============================================================================
# 内部辅助函数
# ============================================================================

def _find_module_for_class(class_name: str) -> Optional[str]:
    """查找类所在的模块"""
    all_modules = _get_global_modules()

    # 优先级列表
    priority_modules = ['Core', 'CoreUObject', 'Engine', 'Renderer', 'RHI']

    # 1. 先搜索优先级模块
    for module_name in priority_modules:
        graph = _load_module_graph(module_name)
        if graph and f"class_{{class_name}}" in graph.nodes:
            return module_name

    # 2. 搜索所有 Runtime 模块
    for module_name, info in all_modules.items():
        if info.get('category') == 'Runtime':
            if module_name in priority_modules:
                continue
            graph = _load_module_graph(module_name)
            if graph and f"class_{{class_name}}" in graph.nodes:
                return module_name

    # 3. 搜索所有模块（限制前200个）
    for module_name in list(all_modules.keys())[:200]:
        if module_name in priority_modules:
            continue
        graph = _load_module_graph(module_name)
        if graph and f"class_{{class_name}}" in graph.nodes:
            return module_name

    return None
